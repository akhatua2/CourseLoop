{"ast":null,"code":"var _jsxFileName = \"/Users/sidrajaram/Desktop/hackillinois/Course_Loop/src/features/gifs/Gif/Gif.tsx\";\nimport React, { useState, useEffect, useRef, useMemo } from \"react\";\nimport { Placeholder, Wrapper } from \"./Gif.style\";\nimport { useVisibility } from \"foundations/hooks/useVisibility\";\nvar GifSize;\n\n(function (GifSize) {\n  GifSize[GifSize[\"Preview\"] = 0] = \"Preview\";\n  GifSize[GifSize[\"Full\"] = 1] = \"Full\";\n})(GifSize || (GifSize = {}));\n\nvar GifFormat;\n\n(function (GifFormat) {\n  GifFormat[GifFormat[\"Image\"] = 0] = \"Image\";\n  GifFormat[GifFormat[\"Video\"] = 1] = \"Video\";\n})(GifFormat || (GifFormat = {}));\n\n// preload the image/video and choose the optimal format\nconst load = async source => {\n  let image = {\n    src: source.mp4,\n    format: GifFormat.Video\n  };\n\n  if (source.webp_size < source.mp4_size && (await supportsWebp())) {\n    image = {\n      src: source.webp,\n      format: GifFormat.Image\n    };\n  } // fetch in the background\n\n\n  const response = await fetch(image.src); // blob enures the entire file has loaded\n\n  const blob = await response.blob(); // return a url for the blob, which will load immediately\n\n  return { ...image,\n    src: URL.createObjectURL(blob)\n  };\n}; // null while loading, updated when complete\n\n\nconst useBackgroundLoad = source => {\n  const [data, setData] = useState(null); // prevent refetching the same image multiple times\n\n  const image = useMemo(() => load(source), [source]);\n  useEffect(() => {\n    let mounted = true;\n    let url = null;\n\n    (async () => {\n      const loaded = await image;\n      url = loaded.src;\n\n      if (mounted) {\n        // only update state if the component is mounted\n        setData(loaded);\n      }\n    })();\n\n    return () => {\n      mounted = false; // free memory from the image\n\n      if (url) {\n        URL.revokeObjectURL(url);\n      }\n    };\n  }, [image]);\n  return data;\n}; // check for webp browser support (needed to support safari)\n\n\nconst supportsWebp = () => {\n  return new Promise(resolve => {\n    const image = new Image(); // check that the image is loaded successfully\n\n    image.onload = () => {\n      resolve(image.width > 0 && image.height > 0);\n    }; // data uri of animated webp to test for support\n\n\n    image.src = \"data:image/webp;base64,UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\";\n  });\n};\n\n// load the gif in the background, swapping in for a placeholder when fully loaded\nconst GifDisplay = React.memo(({\n  source,\n  title\n}) => {\n  const image = useBackgroundLoad(source);\n\n  if (image !== null) {\n    if (image.format === GifFormat.Image) {\n      return /*#__PURE__*/React.createElement(\"img\", {\n        src: image.src,\n        alt: title,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 96,\n          columnNumber: 16\n        }\n      });\n    } else {\n      return /*#__PURE__*/React.createElement(\"video\", {\n        autoPlay: true,\n        loop: true,\n        muted: true,\n        playsInline: true,\n        src: image.src,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 98,\n          columnNumber: 16\n        }\n      });\n    }\n  }\n\n  return /*#__PURE__*/React.createElement(Placeholder, {\n    width: source.width,\n    height: source.height,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 101,\n      columnNumber: 12\n    }\n  });\n}, (prev, next) => {\n  return prev.source.url === next.source.url;\n});\n\n// lazy load a gif, waiting until it is nearly visible to being loading\nconst Gif = ({\n  gif,\n  size,\n  container = null,\n  onClick\n}) => {\n  const ref = useRef(null);\n  const isVisible = useVisibility(ref, container, 0, \"50px 0px\", true);\n  const username = gif.user ? gif.user.username : gif.username;\n  const source = size === GifSize.Full ? gif.images.original : gif.images.fixed_width;\n  return /*#__PURE__*/React.createElement(Wrapper, {\n    title: `${gif.title}${username && ` | @${username}`}`,\n    ref: ref,\n    onClick: () => onClick && onClick(gif),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 124,\n      columnNumber: 5\n    }\n  }, isVisible ? /*#__PURE__*/React.createElement(GifDisplay, {\n    source: source,\n    title: gif.title,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 9\n    }\n  }) : /*#__PURE__*/React.createElement(Placeholder, {\n    width: source.width,\n    height: source.height,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 132,\n      columnNumber: 9\n    }\n  }));\n};\n\nexport { Gif, GifDisplay, GifSize };","map":{"version":3,"sources":["/Users/sidrajaram/Desktop/hackillinois/Course_Loop/src/features/gifs/Gif/Gif.tsx"],"names":["React","useState","useEffect","useRef","useMemo","Placeholder","Wrapper","useVisibility","GifSize","GifFormat","load","source","image","src","mp4","format","Video","webp_size","mp4_size","supportsWebp","webp","Image","response","fetch","blob","URL","createObjectURL","useBackgroundLoad","data","setData","mounted","url","loaded","revokeObjectURL","Promise","resolve","onload","width","height","GifDisplay","memo","title","prev","next","Gif","gif","size","container","onClick","ref","isVisible","username","user","Full","images","original","fixed_width"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useRef, useMemo } from \"react\";\nimport { IGif, ImageAllTypes } from \"@giphy/js-types\";\nimport { Placeholder, Wrapper } from \"./Gif.style\";\nimport { useVisibility } from \"foundations/hooks/useVisibility\";\n\nenum GifSize {\n  Preview,\n  Full,\n}\n\nenum GifFormat {\n  Image,\n  Video,\n}\n\ninterface LoadedGif {\n  src: string;\n  format: GifFormat;\n}\n\n// preload the image/video and choose the optimal format\nconst load = async (source: ImageAllTypes): Promise<LoadedGif> => {\n  let image = {\n    src: source.mp4,\n    format: GifFormat.Video,\n  };\n  if (source.webp_size < source.mp4_size && (await supportsWebp())) {\n    image = {\n      src: source.webp,\n      format: GifFormat.Image,\n    };\n  }\n  // fetch in the background\n  const response = await fetch(image.src);\n  // blob enures the entire file has loaded\n  const blob = await response.blob();\n  // return a url for the blob, which will load immediately\n  return {\n    ...image,\n    src: URL.createObjectURL(blob),\n  };\n};\n\n// null while loading, updated when complete\nconst useBackgroundLoad = (source: ImageAllTypes): null | LoadedGif => {\n  const [data, setData] = useState<null | LoadedGif>(null);\n  // prevent refetching the same image multiple times\n  const image = useMemo(() => load(source), [source]);\n  useEffect(() => {\n    let mounted = true;\n    let url: null | string = null;\n    (async () => {\n      const loaded = await image;\n      url = loaded.src;\n      if (mounted) {\n        // only update state if the component is mounted\n        setData(loaded);\n      }\n    })();\n    return () => {\n      mounted = false;\n      // free memory from the image\n      if (url) {\n        URL.revokeObjectURL(url);\n      }\n    };\n  }, [image]);\n  return data;\n};\n\n// check for webp browser support (needed to support safari)\nconst supportsWebp = (): Promise<boolean> => {\n  return new Promise((resolve) => {\n    const image = new Image();\n    // check that the image is loaded successfully\n    image.onload = () => {\n      resolve(image.width > 0 && image.height > 0);\n    };\n    // data uri of animated webp to test for support\n    image.src =\n      \"data:image/webp;base64,UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA\";\n  });\n};\n\ninterface GifDisplayProps {\n  source: ImageAllTypes;\n  title: string;\n}\n\n// load the gif in the background, swapping in for a placeholder when fully loaded\nconst GifDisplay = React.memo(\n  ({ source, title }: GifDisplayProps) => {\n    const image = useBackgroundLoad(source);\n    if (image !== null) {\n      if (image.format === GifFormat.Image) {\n        return <img src={image.src} alt={title} />;\n      } else {\n        return <video autoPlay loop muted playsInline src={image.src} />;\n      }\n    }\n    return <Placeholder width={source.width} height={source.height} />;\n  },\n  (prev, next) => {\n    return prev.source.url === next.source.url;\n  }\n);\n\ninterface GifProps {\n  gif: IGif;\n  size: GifSize;\n  container?: React.RefObject<HTMLElement> | null;\n  onClick?: (gif: IGif) => void;\n}\n\n// lazy load a gif, waiting until it is nearly visible to being loading\nconst Gif = ({ gif, size, container = null, onClick }: GifProps) => {\n  const ref = useRef<HTMLDivElement>(null);\n  const isVisible = useVisibility(ref, container, 0, \"50px 0px\", true);\n  const username = gif.user ? gif.user.username : gif.username;\n  const source =\n    size === GifSize.Full ? gif.images.original : gif.images.fixed_width;\n\n  return (\n    <Wrapper\n      title={`${gif.title}${username && ` | @${username}`}`}\n      ref={ref}\n      onClick={() => onClick && onClick(gif)}\n    >\n      {isVisible ? (\n        <GifDisplay source={source} title={gif.title} />\n      ) : (\n        <Placeholder width={source.width} height={source.height} />\n      )}\n    </Wrapper>\n  );\n};\n\nexport { Gif, GifDisplay, GifSize };\n"]},"metadata":{},"sourceType":"module"}