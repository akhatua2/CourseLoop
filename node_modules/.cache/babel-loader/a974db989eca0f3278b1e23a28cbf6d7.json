{"ast":null,"code":"var _jsxFileName = \"/Users/sidrajaram/Desktop/hackillinois/Course_Loop/src/features/gifs/GifPicker/GifPicker.tsx\";\nimport React, { useState, useEffect, useRef } from \"react\";\nimport { Wrapper, Search, Marker, Results, Column, Group, Scroll, Attribution } from \"./GifPicker.style\";\nimport { PlaceholderMessage, placeholderMessages } from \"./PlaceholderMessage\";\nimport { Gif, GifSize } from \"../Gif\";\nimport { useVisibility } from \"foundations/hooks/useVisibility\";\nimport { useDebounce } from \"foundations/hooks/useDebounce\";\nimport attribution from \"features/messages/GiphyMessageDisplay/attribution.png\"; // separate an array into count subarrays\n\nconst splitColumns = (page, count) => {\n  return page.reduce((columns, item, index) => {\n    columns[index % count].push(item);\n    return columns;\n  }, new Array(count).fill(0).map(v => []));\n};\n\nconst PAGE_SIZE = 24; // make a request to the giphy search api\n\nconst search = async (query, page) => {\n  try {\n    const response = await fetch(`https://api.giphy.com/v1/gifs/search?api_key=${process.env.REACT_APP_GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=${PAGE_SIZE}&offset=${page * PAGE_SIZE}&rating=G&lang=en`);\n    const results = await response.json();\n    return results.data;\n  } catch {\n    // fail softly\n    return [];\n  }\n}; // hook to fetch gifs with paging and waiting status (wether page should be allowed to incriment)\n\n\nconst useGifs = (query, page) => {\n  const [gifs, setGifs] = useState(null);\n  const [waiting, setWaiting] = useState(false); // reset when the query changes\n\n  useEffect(() => {\n    setGifs(null);\n  }, [query]);\n  useEffect(() => {\n    let mounted = true;\n    let scheduled;\n\n    (async () => {\n      // query cannot be empty\n      if (query.length < 1) {\n        return;\n      }\n\n      setWaiting(true);\n      const data = await search(query, page); // add the retrived gifs to the results\n\n      if (mounted) {\n        // split the page into two columns and add\n        setGifs(gifs => (gifs && page > 0 ? gifs : []).concat(splitColumns(data, 2))); // add a buffer on the end before marking as loaded\n\n        scheduled = setTimeout(() => {\n          mounted && setWaiting(false);\n        }, 500);\n      }\n    })(); // prevent state updates aginst unmounted component\n\n\n    return () => {\n      mounted = false;\n\n      if (scheduled) {\n        clearTimeout(scheduled);\n      }\n    };\n  }, [page, query]);\n  return [waiting, gifs];\n}; // chunking the results allows for minimal rerenders as gifs are added\n// all the gifs from a request that should go into a single column (i.e. half the results)\n\n\nconst ResultsGroup = React.memo(({\n  results,\n  container,\n  id,\n  onSelected\n}) => {\n  return /*#__PURE__*/React.createElement(Group, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 7\n    }\n  }, results.map((gif, index) => /*#__PURE__*/React.createElement(Gif, {\n    gif: gif,\n    size: GifSize.Preview,\n    onClick: onSelected,\n    key: `gif-results.group.${id}.gif.${index}`,\n    container: container,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 11\n    }\n  })));\n}); // all of the groups that go in the same column\n\nconst ResultsColumn = ({\n  results,\n  container,\n  id,\n  markerRef,\n  onSelected\n}) => {\n  return /*#__PURE__*/React.createElement(Column, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 5\n    }\n  }, results.map((column, index) => /*#__PURE__*/React.createElement(ResultsGroup, {\n    results: column,\n    container: container,\n    id: id + 2 * index,\n    key: `gif-results.column.${id}.group.${index}`,\n    onSelected: onSelected,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 9\n    }\n  })), /*#__PURE__*/React.createElement(Marker, {\n    ref: markerRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 148,\n      columnNumber: 7\n    }\n  }));\n};\n\nconst SearchResults = React.memo(({\n  results,\n  container,\n  refs,\n  onSelected\n}) => {\n  const columns = splitColumns(results, 2);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, columns.map((column, index) => /*#__PURE__*/React.createElement(ResultsColumn, {\n    results: column,\n    container: container,\n    id: index,\n    key: `gif-results.column.${index}`,\n    markerRef: refs[index],\n    onSelected: onSelected,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 169,\n      columnNumber: 11\n    }\n  })));\n});\n\n// gif picker with infinite loading and search\nconst GifPicker = ({\n  onSelected\n}) => {\n  const [query, setQuery] = useState(\"\"); // prevent excessive fetching\n\n  const debouncedQuery = useDebounce(query, 400);\n  const [page, setPage] = useState(0);\n  const [waiting, results] = useGifs(debouncedQuery, page); // refs for lazy loading\n\n  const picker = useRef(null); // refs and intersection observers for infinite scroll\n\n  const scrollBottomLeft = useRef(null);\n  const scrollBottomRight = useRef(null);\n  const atBottomRight = useVisibility(scrollBottomLeft, picker, 0, \"0px 0px 0px 100px\");\n  const atBottomLeft = useVisibility(scrollBottomRight, picker, 0, \"0px 0px 0px 100px\");\n\n  const curried = gif => onSelected(gif, query); // if the search changes, reset the page\n\n\n  useEffect(() => {\n    setPage(0);\n  }, [query]); // infinite scroll\n\n  useEffect(() => {\n    // not waiting, at the bottom, and the last page of results was full\n    if (!waiting && (atBottomLeft || atBottomRight) && results && results.length > 0 && results[results.length - 1].length >= PAGE_SIZE / 2) {\n      // increase the page (new gifs will be fetched)\n      setPage(page => page + 1);\n    }\n  }, [waiting, atBottomLeft, atBottomRight, results]);\n  return /*#__PURE__*/React.createElement(Wrapper, {\n    ref: picker,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 238,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(Search, {\n    placeholder: \"Search GIPHY\",\n    value: query,\n    onChange: e => setQuery(e.target.value),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 239,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(Scroll, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 244,\n      columnNumber: 7\n    }\n  }, !query && /*#__PURE__*/React.createElement(PlaceholderMessage, {\n    message: placeholderMessages.empty,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 245,\n      columnNumber: 20\n    }\n  }), query && results && results[0].length === 0 && /*#__PURE__*/React.createElement(PlaceholderMessage, {\n    message: placeholderMessages.notFound,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 247,\n      columnNumber: 11\n    }\n  }), /*#__PURE__*/React.createElement(Results, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 249,\n      columnNumber: 9\n    }\n  }, /*#__PURE__*/React.createElement(SearchResults, {\n    results: results || [[], []],\n    container: picker,\n    refs: [scrollBottomLeft, scrollBottomRight],\n    onSelected: curried,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 250,\n      columnNumber: 11\n    }\n  }))), /*#__PURE__*/React.createElement(Attribution, {\n    src: attribution,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 258,\n      columnNumber: 7\n    }\n  }));\n};\n\nexport { GifPicker };","map":{"version":3,"sources":["/Users/sidrajaram/Desktop/hackillinois/Course_Loop/src/features/gifs/GifPicker/GifPicker.tsx"],"names":["React","useState","useEffect","useRef","Wrapper","Search","Marker","Results","Column","Group","Scroll","Attribution","PlaceholderMessage","placeholderMessages","Gif","GifSize","useVisibility","useDebounce","attribution","splitColumns","page","count","reduce","columns","item","index","push","Array","fill","map","v","PAGE_SIZE","search","query","response","fetch","process","env","REACT_APP_GIPHY_API_KEY","encodeURIComponent","results","json","data","useGifs","gifs","setGifs","waiting","setWaiting","mounted","scheduled","length","concat","setTimeout","clearTimeout","ResultsGroup","memo","container","id","onSelected","gif","Preview","ResultsColumn","markerRef","column","SearchResults","refs","GifPicker","setQuery","debouncedQuery","setPage","picker","scrollBottomLeft","scrollBottomRight","atBottomRight","atBottomLeft","curried","e","target","value","empty","notFound"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useRef } from \"react\";\nimport {\n  Wrapper,\n  Search,\n  Marker,\n  Results,\n  Column,\n  Group,\n  Scroll,\n  Attribution,\n} from \"./GifPicker.style\";\nimport { PlaceholderMessage, placeholderMessages } from \"./PlaceholderMessage\";\nimport { IGif } from \"@giphy/js-types\";\nimport { Gif, GifSize } from \"../Gif\";\nimport { useVisibility } from \"foundations/hooks/useVisibility\";\nimport { useDebounce } from \"foundations/hooks/useDebounce\";\nimport attribution from \"features/messages/GiphyMessageDisplay/attribution.png\";\n\n// separate an array into count subarrays\nconst splitColumns = <T,>(page: T[], count: number) => {\n  return page.reduce((columns, item, index) => {\n    columns[index % count].push(item);\n    return columns;\n  }, new Array(count).fill(0).map((v) => []) as T[][]);\n};\n\nconst PAGE_SIZE = 24;\n// make a request to the giphy search api\nconst search = async (query: string, page: number): Promise<IGif[]> => {\n  try {\n    const response = await fetch(\n      `https://api.giphy.com/v1/gifs/search?api_key=${\n        process.env.REACT_APP_GIPHY_API_KEY\n      }&q=${encodeURIComponent(query)}&limit=${PAGE_SIZE}&offset=${\n        page * PAGE_SIZE\n      }&rating=G&lang=en`\n    );\n    const results = (await response.json()) as { data: IGif[] };\n    return results.data;\n  } catch {\n    // fail softly\n    return [];\n  }\n};\n\n// hook to fetch gifs with paging and waiting status (wether page should be allowed to incriment)\nconst useGifs = (query: string, page: number): [boolean, IGif[][] | null] => {\n  const [gifs, setGifs] = useState<IGif[][] | null>(null);\n  const [waiting, setWaiting] = useState(false);\n\n  // reset when the query changes\n  useEffect(() => {\n    setGifs(null);\n  }, [query]);\n\n  useEffect(() => {\n    let mounted = true;\n    let scheduled: number;\n\n    (async () => {\n      // query cannot be empty\n      if (query.length < 1) {\n        return;\n      }\n      setWaiting(true);\n      const data = await search(query, page);\n      // add the retrived gifs to the results\n      if (mounted) {\n        // split the page into two columns and add\n        setGifs((gifs) =>\n          (gifs && page > 0 ? gifs : []).concat(splitColumns<IGif>(data, 2))\n        );\n        // add a buffer on the end before marking as loaded\n        scheduled = setTimeout(() => {\n          mounted && setWaiting(false);\n        }, 500);\n      }\n    })();\n\n    // prevent state updates aginst unmounted component\n    return () => {\n      mounted = false;\n      if (scheduled) {\n        clearTimeout(scheduled);\n      }\n    };\n  }, [page, query]);\n\n  return [waiting, gifs];\n};\n\n// chunking the results allows for minimal rerenders as gifs are added\n\n// all the gifs from a request that should go into a single column (i.e. half the results)\nconst ResultsGroup = React.memo(\n  ({\n    results,\n    container,\n    id,\n    onSelected,\n  }: {\n    results: IGif[];\n    container: React.RefObject<HTMLDivElement>;\n    id: number;\n    onSelected: onClickHandler;\n  }) => {\n    return (\n      <Group>\n        {results.map((gif, index) => (\n          <Gif\n            gif={gif}\n            size={GifSize.Preview}\n            onClick={onSelected}\n            key={`gif-results.group.${id}.gif.${index}`}\n            container={container}\n          />\n        ))}\n      </Group>\n    );\n  }\n);\n\n// all of the groups that go in the same column\nconst ResultsColumn = ({\n  results,\n  container,\n  id,\n  markerRef,\n  onSelected,\n}: {\n  results: IGif[][];\n  container: React.RefObject<HTMLDivElement>;\n  id: number;\n  markerRef: React.RefObject<HTMLDivElement>;\n  onSelected: onClickHandler;\n}) => {\n  return (\n    <Column>\n      {results.map((column, index) => (\n        <ResultsGroup\n          results={column}\n          container={container}\n          id={id + 2 * index}\n          key={`gif-results.column.${id}.group.${index}`}\n          onSelected={onSelected}\n        ></ResultsGroup>\n      ))}\n      <Marker ref={markerRef} />\n    </Column>\n  );\n};\n\nconst SearchResults = React.memo(\n  ({\n    results,\n    container,\n    refs,\n    onSelected,\n  }: {\n    results: IGif[][];\n    container: React.RefObject<HTMLDivElement>;\n    refs: React.RefObject<HTMLDivElement>[];\n    onSelected: onClickHandler;\n  }) => {\n    const columns = splitColumns<IGif[]>(results, 2);\n    return (\n      <>\n        {columns.map((column, index) => (\n          <ResultsColumn\n            results={column}\n            container={container}\n            id={index}\n            key={`gif-results.column.${index}`}\n            markerRef={refs[index]}\n            onSelected={onSelected}\n          ></ResultsColumn>\n        ))}\n      </>\n    );\n  }\n);\n\nexport type onSelectedHandler = (gif: IGif, query: string) => void;\ntype onClickHandler = (gif: IGif) => void;\n\ninterface GifPickerOptions {\n  onSelected: onSelectedHandler;\n}\n\n// gif picker with infinite loading and search\nconst GifPicker = ({ onSelected }: GifPickerOptions) => {\n  const [query, setQuery] = useState(\"\");\n  // prevent excessive fetching\n  const debouncedQuery = useDebounce(query, 400);\n  const [page, setPage] = useState(0);\n  const [waiting, results] = useGifs(debouncedQuery, page);\n  // refs for lazy loading\n  const picker = useRef<HTMLDivElement>(null);\n  // refs and intersection observers for infinite scroll\n  const scrollBottomLeft = useRef<HTMLDivElement>(null);\n  const scrollBottomRight = useRef<HTMLDivElement>(null);\n  const atBottomRight = useVisibility(\n    scrollBottomLeft,\n    picker,\n    0,\n    \"0px 0px 0px 100px\"\n  );\n  const atBottomLeft = useVisibility(\n    scrollBottomRight,\n    picker,\n    0,\n    \"0px 0px 0px 100px\"\n  );\n\n  const curried = (gif: IGif) => onSelected(gif, query);\n\n  // if the search changes, reset the page\n  useEffect(() => {\n    setPage(0);\n  }, [query]);\n\n  // infinite scroll\n  useEffect(() => {\n    // not waiting, at the bottom, and the last page of results was full\n    if (\n      !waiting &&\n      (atBottomLeft || atBottomRight) &&\n      results &&\n      results.length > 0 &&\n      results[results.length - 1].length >= PAGE_SIZE / 2\n    ) {\n      // increase the page (new gifs will be fetched)\n      setPage((page) => page + 1);\n    }\n  }, [waiting, atBottomLeft, atBottomRight, results]);\n\n  return (\n    <Wrapper ref={picker}>\n      <Search\n        placeholder=\"Search GIPHY\"\n        value={query}\n        onChange={(e) => setQuery(e.target.value)}\n      />\n      <Scroll>\n        {!query && <PlaceholderMessage message={placeholderMessages.empty} />}\n        {query && results && results[0].length === 0 && (\n          <PlaceholderMessage message={placeholderMessages.notFound} />\n        )}\n        <Results>\n          <SearchResults\n            results={results || [[], []]}\n            container={picker}\n            refs={[scrollBottomLeft, scrollBottomRight]}\n            onSelected={curried}\n          />\n        </Results>\n      </Scroll>\n      <Attribution src={attribution} />\n    </Wrapper>\n  );\n};\n\nexport { GifPicker };\n"]},"metadata":{},"sourceType":"module"}