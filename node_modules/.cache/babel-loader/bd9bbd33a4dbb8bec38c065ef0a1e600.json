{"ast":null,"code":"var _jsxFileName = \"/Users/sidrajaram/Desktop/hackillinois/Course_Loop/src/features/currentConversation/MessageList/MessageList.tsx\";\nimport React, { useRef, useEffect, useState, useCallback } from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { createSelector } from \"reselect\";\nimport { MessageListItem } from \"../MessageListItem\";\nimport { getCurrentConversationId } from \"../currentConversationModel\";\nimport { getUsersById } from \"features/users/userModel\";\nimport { getMessagesById } from \"features/messages/messageModel\";\nimport { Wrapper } from \"./MessageList.style\";\nimport WelcomeMessage from \"./WelcomeMessage\";\nimport { UserInitialsAvatar } from \"foundations/components/UserInitialsAvatar\";\n/**\n * Create a selector that that returns the list of messages in the currentConversation joined\n * to the user that sent that message\n *\n * TODO:\n * This implementation will cause the dependant component to re-render if any user data has changed\n * if the current conversation has changed or if any message has changed or if any user has changed.\n * This needs to be reduced in scope\n *\n * TODO: This needs to sort by time token; object keys are not guarenteed to retain order in js.\n */\n\nexport const getCurrentConversationMessages = createSelector([getMessagesById, getCurrentConversationId, getUsersById], (messages, conversationId, users) => {\n  return messages[conversationId] ? Object.values(messages[conversationId]).filter(message => message.channel === conversationId).map(message => {\n    return { ...message,\n      timetoken: String(message.timetoken),\n      sender: users[message.message.senderId] || (message.message.senderId ? {\n        id: message.message.senderId,\n        name: message.message.senderId\n      } : {\n        id: \"unknown\",\n        name: \"unknown\"\n      })\n    };\n  }) : [];\n});\n\nconst MessageList = () => {\n  const conversationId = useSelector(getCurrentConversationId);\n  const [conversationsScrollPositions, setConversationsScrollPositions] = useState({});\n\n  const updateCurrentConversationScrollPosition = scrollPosition => {\n    setConversationsScrollPositions({ ...conversationsScrollPositions,\n      [conversationId]: scrollPosition\n    });\n  };\n\n  const handleScroll = e => {\n    const scrollPosition = e.target.scrollTop;\n\n    if (scrollPosition !== 0) {\n      updateCurrentConversationScrollPosition(scrollPosition);\n    }\n  };\n\n  const restoreConversationScrollPosition = conversationId => {\n    const conversationScrollPosition = conversationsScrollPositions[conversationId];\n\n    if (conversationScrollPosition) {\n      wrapper.current.scrollTo(0, conversationScrollPosition);\n    }\n  };\n\n  const memoizedRestoreConversationScrollPositionCallback = useCallback(restoreConversationScrollPosition, [conversationId]);\n  const messages = useSelector(getCurrentConversationMessages);\n  const wrapper = useRef(document.createElement(\"div\"));\n  const el = wrapper.current;\n  const scrollToBottom = useCallback(() => {\n    return el.scrollTop = el.scrollHeight - el.clientHeight;\n  }, [el]);\n  const hasReachedBottom = el.scrollHeight - el.clientHeight === el.scrollTop;\n  useEffect(() => {\n    if (hasReachedBottom) {\n      scrollToBottom();\n    }\n  }, [messages.length, hasReachedBottom, scrollToBottom]);\n  useEffect(() => {\n    memoizedRestoreConversationScrollPositionCallback(conversationId);\n  }, [memoizedRestoreConversationScrollPositionCallback, conversationId]);\n  return /*#__PURE__*/React.createElement(Wrapper, {\n    ref: wrapper,\n    onScroll: handleScroll,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(WelcomeMessage, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 7\n    }\n  }), messages.map(message => /*#__PURE__*/React.createElement(MessageListItem, {\n    messageFragment: message,\n    key: message.timetoken,\n    avatar: /*#__PURE__*/React.createElement(UserInitialsAvatar, {\n      size: 36,\n      name: message.sender.name,\n      userId: message.sender.id,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 120,\n        columnNumber: 13\n      }\n    }),\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 9\n    }\n  })));\n};\n\nexport { MessageList };","map":{"version":3,"sources":["/Users/sidrajaram/Desktop/hackillinois/Course_Loop/src/features/currentConversation/MessageList/MessageList.tsx"],"names":["React","useRef","useEffect","useState","useCallback","useSelector","createSelector","MessageListItem","getCurrentConversationId","getUsersById","getMessagesById","Wrapper","WelcomeMessage","UserInitialsAvatar","getCurrentConversationMessages","messages","conversationId","users","Object","values","filter","message","channel","map","timetoken","String","sender","senderId","id","name","MessageList","conversationsScrollPositions","setConversationsScrollPositions","updateCurrentConversationScrollPosition","scrollPosition","handleScroll","e","target","scrollTop","restoreConversationScrollPosition","conversationScrollPosition","wrapper","current","scrollTo","memoizedRestoreConversationScrollPositionCallback","document","createElement","el","scrollToBottom","scrollHeight","clientHeight","hasReachedBottom","length"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,MAAhB,EAAwBC,SAAxB,EAAmCC,QAAnC,EAA6CC,WAA7C,QAAgE,OAAhE;AACA,SAASC,WAAT,QAA4B,aAA5B;AACA,SAASC,cAAT,QAA+B,UAA/B;AACA,SAASC,eAAT,QAAiD,oBAAjD;AACA,SAASC,wBAAT,QAAyC,6BAAzC;AACA,SAASC,YAAT,QAA6B,0BAA7B;AACA,SAASC,eAAT,QAAgC,gCAAhC;AACA,SAASC,OAAT,QAAwB,qBAAxB;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AACA,SAASC,kBAAT,QAAmC,2CAAnC;AAEA;;;;;;;;;;;;AAWA,OAAO,MAAMC,8BAA8B,GAAGR,cAAc,CAC1D,CAACI,eAAD,EAAkBF,wBAAlB,EAA4CC,YAA5C,CAD0D,EAE1D,CAACM,QAAD,EAAWC,cAAX,EAA2BC,KAA3B,KAAwD;AACtD,SAAOF,QAAQ,CAACC,cAAD,CAAR,GACHE,MAAM,CAACC,MAAP,CAAcJ,QAAQ,CAACC,cAAD,CAAtB,EACGI,MADH,CACWC,OAAD,IAAaA,OAAO,CAACC,OAAR,KAAoBN,cAD3C,EAEGO,GAFH,CAGKF,OAAD,IAA8B;AAC5B,WAAO,EACL,GAAGA,OADE;AAELG,MAAAA,SAAS,EAAEC,MAAM,CAACJ,OAAO,CAACG,SAAT,CAFZ;AAGLE,MAAAA,MAAM,EACHT,KAAK,CAACI,OAAO,CAACA,OAAR,CAAgBM,QAAjB,CAAN,KAICN,OAAO,CAACA,OAAR,CAAgBM,QAAhB,GACG;AACEC,QAAAA,EAAE,EAAEP,OAAO,CAACA,OAAR,CAAgBM,QADtB;AAEEE,QAAAA,IAAI,EAAER,OAAO,CAACA,OAAR,CAAgBM;AAFxB,OADH,GAKG;AACEC,QAAAA,EAAE,EAAE,SADN;AAEEC,QAAAA,IAAI,EAAE;AAFR,OATJ;AAJG,KAAP;AAkBD,GAtBL,CADG,GAyBH,EAzBJ;AA0BD,CA7ByD,CAArD;;AAgCP,MAAMC,WAAW,GAAG,MAAM;AAExB,QAAMd,cAAsB,GAAGX,WAAW,CAACG,wBAAD,CAA1C;AACA,QAAM,CACJuB,4BADI,EAEJC,+BAFI,IAGF7B,QAAQ,CAAkC,EAAlC,CAHZ;;AAKA,QAAM8B,uCAAuC,GAAIC,cAAD,IAA4B;AAC1EF,IAAAA,+BAA+B,CAAC,EAC9B,GAAGD,4BAD2B;AAE9B,OAACf,cAAD,GAAkBkB;AAFY,KAAD,CAA/B;AAID,GALD;;AAOA,QAAMC,YAAY,GAAIC,CAAD,IAAY;AAC/B,UAAMF,cAAc,GAAGE,CAAC,CAACC,MAAF,CAASC,SAAhC;;AACA,QAAIJ,cAAc,KAAK,CAAvB,EAA0B;AACxBD,MAAAA,uCAAuC,CAACC,cAAD,CAAvC;AACD;AACF,GALD;;AAOA,QAAMK,iCAAiC,GAAIvB,cAAD,IAA4B;AACpE,UAAMwB,0BAAkC,GACtCT,4BAA4B,CAACf,cAAD,CAD9B;;AAEA,QAAIwB,0BAAJ,EAAgC;AAC9BC,MAAAA,OAAO,CAACC,OAAR,CAAgBC,QAAhB,CAAyB,CAAzB,EAA4BH,0BAA5B;AACD;AACF,GAND;;AAQA,QAAMI,iDAAiD,GAAGxC,WAAW,CACnEmC,iCADmE,EAEnE,CAACvB,cAAD,CAFmE,CAArE;AAKA,QAAMD,QAA2B,GAAGV,WAAW,CAC7CS,8BAD6C,CAA/C;AAGA,QAAM2B,OAAO,GAAGxC,MAAM,CAAiB4C,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAjB,CAAtB;AACA,QAAMC,EAAE,GAAGN,OAAO,CAACC,OAAnB;AAEA,QAAMM,cAAc,GAAG5C,WAAW,CAAC,MAAM;AACvC,WAAQ2C,EAAE,CAACT,SAAH,GAAeS,EAAE,CAACE,YAAH,GAAkBF,EAAE,CAACG,YAA5C;AACD,GAFiC,EAE/B,CAACH,EAAD,CAF+B,CAAlC;AAIA,QAAMI,gBAAgB,GAAGJ,EAAE,CAACE,YAAH,GAAkBF,EAAE,CAACG,YAArB,KAAsCH,EAAE,CAACT,SAAlE;AAEApC,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIiD,gBAAJ,EAAsB;AACpBH,MAAAA,cAAc;AACf;AACF,GAJQ,EAIN,CAACjC,QAAQ,CAACqC,MAAV,EAAkBD,gBAAlB,EAAoCH,cAApC,CAJM,CAAT;AAMA9C,EAAAA,SAAS,CAAC,MAAM;AACd0C,IAAAA,iDAAiD,CAAC5B,cAAD,CAAjD;AACD,GAFQ,EAEN,CAAC4B,iDAAD,EAAoD5B,cAApD,CAFM,CAAT;AAIA,sBACE,oBAAC,OAAD;AAAS,IAAA,GAAG,EAAEyB,OAAd;AAAuB,IAAA,QAAQ,EAAEN,YAAjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE,oBAAC,cAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADF,EAEGpB,QAAQ,CAACQ,GAAT,CAAcF,OAAD,iBACZ,oBAAC,eAAD;AACE,IAAA,eAAe,EAAEA,OADnB;AAEE,IAAA,GAAG,EAAEA,OAAO,CAACG,SAFf;AAGE,IAAA,MAAM,eACJ,oBAAC,kBAAD;AACE,MAAA,IAAI,EAAE,EADR;AAEE,MAAA,IAAI,EAAEH,OAAO,CAACK,MAAR,CAAeG,IAFvB;AAGE,MAAA,MAAM,EAAER,OAAO,CAACK,MAAR,CAAeE,EAHzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAJJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADD,CAFH,CADF;AAkBD,CA3ED;;AA6EA,SAASE,WAAT","sourcesContent":["import React, { useRef, useEffect, useState, useCallback } from \"react\";\nimport { useSelector } from \"react-redux\";\nimport { createSelector } from \"reselect\";\nimport { MessageListItem, MessageFragment } from \"../MessageListItem\";\nimport { getCurrentConversationId } from \"../currentConversationModel\";\nimport { getUsersById } from \"features/users/userModel\";\nimport { getMessagesById } from \"features/messages/messageModel\";\nimport { Wrapper } from \"./MessageList.style\";\nimport WelcomeMessage from \"./WelcomeMessage\";\nimport { UserInitialsAvatar } from \"foundations/components/UserInitialsAvatar\";\n\n/**\n * Create a selector that that returns the list of messages in the currentConversation joined\n * to the user that sent that message\n *\n * TODO:\n * This implementation will cause the dependant component to re-render if any user data has changed\n * if the current conversation has changed or if any message has changed or if any user has changed.\n * This needs to be reduced in scope\n *\n * TODO: This needs to sort by time token; object keys are not guarenteed to retain order in js.\n */\nexport const getCurrentConversationMessages = createSelector(\n  [getMessagesById, getCurrentConversationId, getUsersById],\n  (messages, conversationId, users): MessageFragment[] => {\n    return messages[conversationId]\n      ? Object.values(messages[conversationId])\n          .filter((message) => message.channel === conversationId)\n          .map(\n            (message): MessageFragment => {\n              return {\n                ...message,\n                timetoken: String(message.timetoken),\n                sender:\n                  (users[message.message.senderId] as {\n                    id: string;\n                    name: string;\n                  }) ||\n                  (message.message.senderId\n                    ? {\n                        id: message.message.senderId,\n                        name: message.message.senderId,\n                      }\n                    : {\n                        id: \"unknown\",\n                        name: \"unknown\",\n                      }),\n              };\n            }\n          )\n      : [];\n  }\n);\n\nconst MessageList = () => {\n  type ConversationScrollPositionsType = { [conversationId: string]: number };\n  const conversationId: string = useSelector(getCurrentConversationId);\n  const [\n    conversationsScrollPositions,\n    setConversationsScrollPositions,\n  ] = useState<ConversationScrollPositionsType>({});\n\n  const updateCurrentConversationScrollPosition = (scrollPosition: number) => {\n    setConversationsScrollPositions({\n      ...conversationsScrollPositions,\n      [conversationId]: scrollPosition,\n    });\n  };\n\n  const handleScroll = (e: any) => {\n    const scrollPosition = e.target.scrollTop;\n    if (scrollPosition !== 0) {\n      updateCurrentConversationScrollPosition(scrollPosition);\n    }\n  };\n\n  const restoreConversationScrollPosition = (conversationId: string) => {\n    const conversationScrollPosition: number =\n      conversationsScrollPositions[conversationId];\n    if (conversationScrollPosition) {\n      wrapper.current.scrollTo(0, conversationScrollPosition);\n    }\n  };\n\n  const memoizedRestoreConversationScrollPositionCallback = useCallback(\n    restoreConversationScrollPosition,\n    [conversationId]\n  );\n\n  const messages: MessageFragment[] = useSelector(\n    getCurrentConversationMessages\n  );\n  const wrapper = useRef<HTMLDivElement>(document.createElement(\"div\"));\n  const el = wrapper.current;\n\n  const scrollToBottom = useCallback(() => {\n    return (el.scrollTop = el.scrollHeight - el.clientHeight);\n  }, [el]);\n\n  const hasReachedBottom = el.scrollHeight - el.clientHeight === el.scrollTop;\n\n  useEffect(() => {\n    if (hasReachedBottom) {\n      scrollToBottom();\n    }\n  }, [messages.length, hasReachedBottom, scrollToBottom]);\n\n  useEffect(() => {\n    memoizedRestoreConversationScrollPositionCallback(conversationId);\n  }, [memoizedRestoreConversationScrollPositionCallback, conversationId]);\n\n  return (\n    <Wrapper ref={wrapper} onScroll={handleScroll}>\n      <WelcomeMessage />\n      {messages.map((message) => (\n        <MessageListItem\n          messageFragment={message}\n          key={message.timetoken}\n          avatar={\n            <UserInitialsAvatar\n              size={36}\n              name={message.sender.name}\n              userId={message.sender.id}\n            />\n          }\n        />\n      ))}\n    </Wrapper>\n  );\n};\n\nexport { MessageList };\n"]},"metadata":{},"sourceType":"module"}