{"ast":null,"code":"import { useState, useEffect } from \"react\";\nexport const useVisibility = (element, container, threshold, rootMargin, lock = false) => {\n  // exposes a piece of state\n  const [isVisible, setVisiblity] = useState(false); // runs once\n\n  useEffect(() => {\n    const target = element.current; // null uses the viewport\n\n    const root = container && container.current; // ensure the refs are pointing to elements\n\n    if (target !== null) {\n      const observer = new IntersectionObserver(([entry]) => {\n        // after it is shown once, state is locked to prevent scroll jumps\n        if (lock) {\n          if (entry.isIntersecting) {\n            setVisiblity(true);\n            observer.unobserve(target);\n          }\n        } else {\n          setVisiblity(entry.isIntersecting);\n        }\n      }, {\n        root,\n        threshold,\n        rootMargin\n      });\n      observer.observe(target); // cleanup\n\n      return () => {\n        observer.unobserve(target);\n      };\n    }\n  }, [container, element, threshold, rootMargin, lock]);\n  return isVisible;\n};","map":{"version":3,"sources":["/Users/sidrajaram/Desktop/hackillinois/Course_Loop/src/foundations/hooks/useVisibility.ts"],"names":["useState","useEffect","useVisibility","element","container","threshold","rootMargin","lock","isVisible","setVisiblity","target","current","root","observer","IntersectionObserver","entry","isIntersecting","unobserve","observe"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,QAAoC,OAApC;AAEA,OAAO,MAAMC,aAAa,GAAG,CAC3BC,OAD2B,EAE3BC,SAF2B,EAG3BC,SAH2B,EAI3BC,UAJ2B,EAK3BC,IAAI,GAAG,KALoB,KAMxB;AACH;AACA,QAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4BT,QAAQ,CAAC,KAAD,CAA1C,CAFG,CAIH;;AACAC,EAAAA,SAAS,CAAC,MAAM;AACd,UAAMS,MAAM,GAAGP,OAAO,CAACQ,OAAvB,CADc,CAEd;;AACA,UAAMC,IAAI,GAAGR,SAAS,IAAIA,SAAS,CAACO,OAApC,CAHc,CAId;;AACA,QAAID,MAAM,KAAK,IAAf,EAAqB;AACnB,YAAMG,QAAQ,GAAG,IAAIC,oBAAJ,CACf,CAAC,CAACC,KAAD,CAAD,KAAa;AACX;AACA,YAAIR,IAAJ,EAAU;AACR,cAAIQ,KAAK,CAACC,cAAV,EAA0B;AACxBP,YAAAA,YAAY,CAAC,IAAD,CAAZ;AACAI,YAAAA,QAAQ,CAACI,SAAT,CAAmBP,MAAnB;AACD;AACF,SALD,MAKO;AACLD,UAAAA,YAAY,CAACM,KAAK,CAACC,cAAP,CAAZ;AACD;AACF,OAXc,EAYf;AAAEJ,QAAAA,IAAF;AAAQP,QAAAA,SAAR;AAAmBC,QAAAA;AAAnB,OAZe,CAAjB;AAcAO,MAAAA,QAAQ,CAACK,OAAT,CAAiBR,MAAjB,EAfmB,CAgBnB;;AACA,aAAO,MAAM;AACXG,QAAAA,QAAQ,CAACI,SAAT,CAAmBP,MAAnB;AACD,OAFD;AAGD;AACF,GA1BQ,EA0BN,CAACN,SAAD,EAAYD,OAAZ,EAAqBE,SAArB,EAAgCC,UAAhC,EAA4CC,IAA5C,CA1BM,CAAT;AA2BA,SAAOC,SAAP;AACD,CAvCM","sourcesContent":["import { useState, useEffect } from \"react\";\n\nexport const useVisibility = (\n  element: React.RefObject<HTMLElement>,\n  container: React.RefObject<HTMLElement> | null,\n  threshold: number,\n  rootMargin: string,\n  lock = false\n) => {\n  // exposes a piece of state\n  const [isVisible, setVisiblity] = useState(false);\n\n  // runs once\n  useEffect(() => {\n    const target = element.current;\n    // null uses the viewport\n    const root = container && container.current;\n    // ensure the refs are pointing to elements\n    if (target !== null) {\n      const observer = new IntersectionObserver(\n        ([entry]) => {\n          // after it is shown once, state is locked to prevent scroll jumps\n          if (lock) {\n            if (entry.isIntersecting) {\n              setVisiblity(true);\n              observer.unobserve(target);\n            }\n          } else {\n            setVisiblity(entry.isIntersecting);\n          }\n        },\n        { root, threshold, rootMargin }\n      );\n      observer.observe(target);\n      // cleanup\n      return () => {\n        observer.unobserve(target);\n      };\n    }\n  }, [container, element, threshold, rootMargin, lock]);\n  return isVisible;\n};\n"]},"metadata":{},"sourceType":"module"}